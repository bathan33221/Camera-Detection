<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Smart Mobile Detector — Clean & Accurate</title>
<style>
body{margin:0;font-family:system-ui,Roboto,Arial;background:#0b0b0b;color:#e6f7ff;display:flex;flex-direction:column;align-items:center;padding:10px;gap:8px}
header{width:100%;display:flex;justify-content:space-between;align-items:center}
h1{font-size:16px;margin:0}
#wrap{width:100%;max-width:720px;display:flex;flex-direction:column;align-items:center}
video{width:100%;height:auto;border-radius:12px;background:#000;}
canvas{position:absolute;left:0;top:0;pointer-events:none}
.viewer{position:relative;width:100%}
.controls{display:flex;gap:8px;flex-wrap:wrap;justify-content:center;margin-top:8px}
button,input,select{padding:8px;border-radius:8px;border:0;background:#111;color:#e6f7ff}
.info{font-size:13px;opacity:.9}
.badge{position:absolute;left:8px;top:8px;background:rgba(0,0,0,.5);padding:6px;border-radius:8px;font-weight:600}
footer{font-size:12px;color:#9aa;margin-top:6px;text-align:center}
.small{font-size:12px;opacity:.9}
.calbox{display:flex;gap:6px;align-items:center}
</style>
</head>
<body>
<header>
  <h1>Smart Mobile Detector</h1>
  <div class="info small">Continuous detection & distance</div>
</header>

<div id="wrap">
  <div class="viewer">
    <video id="video" autoplay playsinline muted></video>
    <canvas id="overlay"></canvas>
    <div class="badge" id="status">Loading models…</div>
  </div>

  <div class="controls">
    <button id="toggleBtn">Stop Detection</button>
    <button id="calibrateBtn">Calibrate</button>
    <div class="calbox">
      <input id="knownWidth" placeholder="Known width cm" style="width:110px" />
      <input id="knownDistance" placeholder="Distance cm" style="width:110px" />
    </div>
    <select id="mode">
      <option value="balanced">Balanced</option>
      <option value="fast">Fast</option>
      <option value="accurate">Accurate</option>
    </select>
  </div>

  <div class="controls small">
    <div id="fps">FPS: —</div>
    <div id="detcount">Detections: —</div>
    <div id="calinfo">Cal: not set</div>
  </div>
</div>

<footer>Tips: steady camera, good lighting. Calibrate for distance. Works on mobile Chrome.</footer>

<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.4.0/dist/tf.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.2/dist/coco-ssd.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/mobilenet@2.2.1/dist/mobilenet.min.js"></script>

<script>
const video=document.getElementById('video');
const overlay=document.getElementById('overlay');
const status=document.getElementById('status');
const fpsEl=document.getElementById('fps'), detcountEl=document.getElementById('detcount'), calinfo=document.getElementById('calinfo');
const toggleBtn=document.getElementById('toggleBtn'), calibrateBtn=document.getElementById('calibrateBtn');
const knownWidthInput=document.getElementById('knownWidth'), knownDistanceInput=document.getElementById('knownDistance'), modeSel=document.getElementById('mode');

let overlayCtx=overlay.getContext('2d');
let model=null, classifier=null;
let detecting=true;
let lastTime=performance.now(), frames=0, fps=0;
let detInterval=250;
let processW=320, processH=240;
let focalLength=null;
let lastDetections=[];

// Start camera
async function startCamera(){
  try{await tf.setBackend('webgl');}catch(e){}
  const constraints={video:{facingMode:'environment',width:{ideal:1280},height:{ideal:720}},audio:false};
  try{
    const stream=await navigator.mediaDevices.getUserMedia(constraints);
    video.srcObject=stream;
    await video.play();
    resizeCanvas();
    window.addEventListener('resize',resizeCanvas);
  }catch(e){alert('Camera access denied: '+e.message); status.innerText='Camera error'; throw e;}
}

function resizeCanvas(){
  overlay.width=video.clientWidth;
  overlay.height=video.clientHeight;
}

// Load models
async function loadModels(){
  status.innerText='Loading coco-ssd…';
  model = await cocoSsd.load();
  status.innerText='Loading mobilenet…';
  classifier = await mobilenet.load();
  status.innerText='Models ready';
  await warmup();
}

async function warmup(){const t=tf.zeros([1,processH,processW,3]);try{await tf.nextFrame();t.dispose();}catch(e){}}

// Refine label (return original label)
function refineLabel(cocoLabel, cropTensor){
  return Promise.resolve(cocoLabel); // use original coco-ssd labels
}

// Detection loop
let loopHandle=null;
async function detectionLoop(){
  if(!detecting || !model) return;
  const start=performance.now();

  const off=document.createElement('canvas');
  off.width=processW; off.height=processH;
  const offCtx=off.getContext('2d');
  offCtx.drawImage(video,0,0,off.width,off.height);

  let predictions=[];
  try{predictions=await model.detect(off);}catch(e){predictions=[];}

  const scaleX=overlay.width/off.width;
  const scaleY=overlay.height/off.height;

  const refined=await Promise.all(predictions.map(async p=>{
    const [x,y,w,h]=p.bbox;
    return {...p, refinedLabel: await refineLabel(p.class,null)};
  }));

  lastDetections=refined;
  drawDetections(refined,scaleX,scaleY);

  frames++; const now=performance.now();
  if(now-lastTime>=1000){fps=Math.round((frames*1000)/(now-lastTime));frames=0;lastTime=now;fpsEl.innerText='FPS: '+fps;}
  detcountEl.innerText='Detections: '+refined.length;

  const elapsed=performance.now()-start;
  const delay=Math.max(80,detInterval-elapsed);
  loopHandle=setTimeout(detectionLoop,delay);
}

// Draw boxes without fade
function drawDetections(preds, scaleX, scaleY){
  overlayCtx.clearRect(0,0,overlay.width,overlay.height);
  overlayCtx.lineWidth=Math.max(2,Math.round(overlay.width*0.004));
  for(const p of preds){
    const [x,y,w,h]=p.bbox;
    const sx=x*scaleX, sy=y*scaleY, sw=w*scaleX, sh=h*scaleY;
    const color=pickColor(p.refinedLabel||p.class);

    overlayCtx.strokeStyle=color;
    overlayCtx.beginPath(); overlayCtx.rect(sx,sy,sw,sh); overlayCtx.stroke();

    let distanceText='—';
    if(focalLength && w>2){
      const pixelWidthAtProcess=w;
      const estimated_cm=(focalLength.realWidthCm*focalLength.focalPx)/Math.max(pixelWidthAtProcess,1);
      distanceText=(estimated_cm/100).toFixed(2)+' m';
    }

    const label=(p.refinedLabel||p.class).toString();
    overlayCtx.font=`${Math.max(12,Math.round(overlay.width*0.03))}px sans-serif`;
    const txtW=overlayCtx.measureText(label+' • '+distanceText).width; const pad=6;
    overlayCtx.fillStyle=hexToRgba(color,0.7);
    overlayCtx.fillRect(sx,Math.max(0,sy-22),txtW+pad*2,20);
    overlayCtx.fillStyle='#fff';
    overlayCtx.fillText(label+' • '+distanceText, sx+pad, Math.max(14,sy-6));
  }
}

// Helpers
function pickColor(name){let h=0;for(let i=0;i<name.length;i++)h=(h*31+name.charCodeAt(i))%360;return`hsl(${h}deg 90% 60%)`;}
function hexToRgba(hsl,a=1){const c=document.createElement('canvas');c.width=1;c.height=1;const cx=c.getContext('2d');cx.fillStyle=hsl;cx.fillRect(0,0,1,1);const d=cx.getImageData(0,0,1,1).data;return`rgba(${d[0]},${d[1]},${d[2]},${a})`;}

// Calibration
function calibrateFromUI(){
  const kw=parseFloat(knownWidthInput.value), kd=parseFloat(knownDistanceInput.value);
  if(!kw||!kd){alert('Enter known width & distance');return;}
  if(!lastDetections||lastDetections.length===0){alert('Show reference object');return;}
  let best=lastDetections.reduce((a,b)=>(b.bbox[2]>a.bbox[2]?b:a),lastDetections[0]);
  const pixelWidth=best.bbox[2];
  const focalPx=(pixelWidth*kd)/kw;
  focalLength={focalPx, realWidthCm:kw, knownDistanceCm:kd};
  calinfo.innerText=`Cal: W=${kw}cm @ ${kd}cm`;
  status.innerText='Calibrated — distances in meters';
}

// UI
toggleBtn.addEventListener('click',()=>{
  detecting=!detecting; toggleBtn.innerText=detecting?'Stop Detection':'Start Detection';
  if(detecting)detectionLoop();
  else{if(loopHandle)clearTimeout(loopHandle);status.innerText='Paused';overlayCtx.clearRect(0,0,overlay.width,overlay.height);}
});
calibrateBtn.addEventListener('click',calibrateFromUI);
modeSel.addEventListener('change',()=>{
  const m=modeSel.value;
  if(m==='fast'){detInterval=150;processW=240;processH=160;}
  else if(m==='accurate'){detInterval=400;processW=480;processH=360;}
  else{detInterval=250;processW=320;processH=240;}
});

// Init
(async function init(){
  try{
    status.innerText='Starting camera…';
    await startCamera();
    status.innerText='Loading models…';
    await loadModels();
    status.innerText='Models loaded — starting detection';
    detectionLoop();
  }catch(e){status.innerText='Init failed: '+(e.message||e);console.error(e);}
})();

window.addEventListener('beforeunload',()=>{try{const s=video.srcObject;if(s)s.getTracks().forEach(t=>t.stop());}catch(e){}});
</script>
</body>
</html>
